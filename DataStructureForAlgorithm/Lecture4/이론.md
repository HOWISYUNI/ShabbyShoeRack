# 재귀함수
프로그램의 핵심 = 되풀이. 비슷한 일을 반복해서 문제를 해결

반복의 해결방법
1. 반복 : iteration
2. 재귀 recursion

## 재귀 Recursion : 스스로를 호출, 재사용 한다
Task가 범위가 더 작은 subTask로 __나눠진다면__ 재귀를 사용한다
점화식이라고 생각하면 됩니다

### 필요조건
1. base condition
2. 재귀호출

ex. Factorial 계산
1. base condition : fact(0) = 1
2. Factorial(n) = n * Factorial(n-1)


## [실습2] 팩토리얼 계산히기
'''python
def factorial(num):
    if num == 0:
        return 1
        
    return num * factorial(num-1)

def main():
    print(factorial(5)) # should return 120

if __name__ == "__main__":
    main()
'''

# 동적프로그래밍 DP = 재귀 + 정보저장(메모이제이션) = 부분문제를 한 번 계산했다면 다시 계산할 필요가 없도록

## [실습2] 피보나치 수열
'''python
class Fib():
    def __init__(self):
        self.memo = {}

    def fibonacci(self, num):
    
        # base
        if num == 0:
            return 0
        if num == 1:
            return 1
        
        
        # Memoization
        if num in self.memo.keys():
            return self.memo[num]
    
        # Recursion & Memoization
        self.memo[num] = self.fibonacci(num-1) + self.fibonacci(num-2)
        
        return self.memo[num]
        
def main():
    f = Fib()
    print(f.fibonacci(10)) # should return 55

if __name__ == "__main__":
    main()
'''


# 트리 : 나무 형태의 자료구조
특징
1. 항상 __Parent__ -> __Child__
    = 방향성이 없음
    = 순환구조 없음
2. __Root__ --> ... --> __Leaf__
    Root : 부모가 없는 노드. 무조건 하나
    Leaf : 자식이 없는 노드
3. 트리의 c깊이(Depth) = Root ~ Leaf 까지 경로의 길이

종류
1. 이진트리 : 모든 노드가 최대 2개의 자식 노드를 가짐
    1. 완전 이진 트리 : (마지막 레벨-1) 레벨까지 모든 노드가 채워진 트리. 왼쪽부터 채워져야함.
    2. 포화 이진 트리 : (마지막) 레벨까지 모든 노드가 채워진 트리
2. 이진탐색트리 : left < parent < right 
    parent
    /   \
  left  right


## 트리의 핵심 : 구석구석 재귀로 탐색한다